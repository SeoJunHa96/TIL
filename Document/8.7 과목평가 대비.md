- 파리 퇴치

  ```python
  T = int(input())
  
  for tc in range(1, T+1):
      N, M = map(int, input().split())
      arr = [list(map(int, input().split())) for i in range(N)]
  
      max_total = 0
      for i in range(N - M + 1):
          for j in range(N - M + 1):
              total = 0
              for x in range(i, i + M):
                  for y in range(j, j + M):
                      total += arr[x][y]
  
                  if max_total < total:
                      max_total = total
      result = max_total
      print(f'#{tc} {result}')
  ```

- 풍선팡

  ```python
  T = int(input())
  
  for tc in range(1, T+1):
      N, M = map(int, input().split())
      arr = [list(map(int, input().split())) for i in range(N)]
  
      max_sum = 0
  
      for i in range(N):
          for j in range(M):
  
              x = arr[i][j]
              sum_lst = arr[i][j]
              # 상 우 하 좌
              for x in range(1, x+1):
                  di = [-x, 0, x, 0]
                  dj = [0, x, 0, -x]
  
                  for k in range(4):
                      ni = i + di[k]
                      nj = j + dj[k]
  
                      if 0 <= ni < N and 0 <= nj < M:
                          sum_lst += arr[ni][nj]
  
                  if sum_lst > max_sum:
                      max_sum = sum_lst
  
      print(f'#{tc} {max_sum}')
  
  ```

- 풍선팡2

  ```python
  # 상 우 하 좌
  di = [-1, 0, 1, 0]
  dj = [0, 1, 0, -1]
  
  T = int(input())
  for tc in range(1, T+1):
      N, M = map(int, input().split())
      arr = [list(map(int, input().split())) for _ in range(N)]
      
      max_v = 0
      for i in range(N):
          for j in range(M):
              count = arr[i][j]  # 터뜨린 풍선의 꽃가루 수
              for k in range(4):
                  ni, nj = i +di[k], j+dj[k]
                  if 0<=ni<N and 0<=nj<M:
                      count += arr[ni][nj]
              if max_v < count:
                  max_v = count
      print(f'#{tc} {max_v}')  
  ```

- 색칠하기

  ```python
  T = int(input())
  
  for tc in range(1, T+1):
      N = int(input())
      paint_area = [list(map(int, input().split())) for _ in range(N)]
  
      red_set = set()
      blu_set = set()
  
      for i in range(N):
          x1, y1, x2, y2, color = paint_area[i]
          for x in range(x1, x2 + 1):
              for y in range(y1, y2 + 1):
                  if color == 1:
                      red_set.add((x, y))
                  if color == 2:
                      blu_set.add((x, y))
  
      result = len(red_set & blu_set)
      print(f'#{tc} {result}')
  ```

  

- 목요일 수업 정리 (서술형)

  ```python
  2차원 배열의 접근 : 행 우선 순회, 열 우선 순회, 지그재그 순회
  # 지그재그 순회
  for i in range(n):
      for j in range(m):
          arr[i][j+(m-1-2*j)*(i&2)]
          
  델타를 이용한 2차 배열 탐색
  전치 행렬 대각선을 기준으로 자리 바꿈
  
  #전치 행렬
  for i in range(3):
      for j in range(3):
          if i < j :
              arr[i][j], arr[j][i] = arr[j][i], arr[i][j]
             
  # 부분집합
  부분집합의 수 : 2**N
  
  # 부분집합 생성 방법 #
  bit = [0, 0, 0, 0]
  for i in range(2):
      bit[0] = i
      for j in range(2):
          bit[1] = j
          for k in range(2):
              bit[2] = k
              for l in range(2):
                  bit[3] = 1
                  print_subset(bit)
  """
  [0, 0, 0, 1]
  [0, 0, 0, 1]
  [0, 0, 1, 1]
  [0, 0, 1, 1]
  [0, 1, 0, 1]
  [0, 1, 0, 1]
  [0, 1, 1, 1]
  [0, 1, 1, 1]
  [1, 0, 0, 1]
  [1, 0, 0, 1]
  [1, 0, 1, 1]
  [1, 0, 1, 1]
  [1, 1, 0, 1]
  [1, 1, 0, 1]
  [1, 1, 1, 1]
  [1, 1, 1, 1]
  """
  
  # 비트 연산자
  & and 연산
  | or 연산
  << / >> 피연산자의 비트 열을 왼쪽/오른쪽 으로 이동시킨다
  
  # 부분집합 생성
  arr = [3, 6, 7, 1, 5, 4]
  n = len(arr)
  for i in range(1<<n): #부분집합의 개수
      for j in range(n):  # 원소의 수만큼 비트를 비교함
          if i & (1<<j): # i 의 j번 비트가 1인 경우
              print(arr[j], end=", ")
      print()
              
  # 개수가 3인 부분집합 생성
  arr = [3, 6, 7, 1, 5, 4]
  n = len(arr)
  for i in range(1<<n): #부분집합의 개수
      subset = []
      for j in range(n):  # 원소의 수만큼 비트를 비교함
          if i & (1<<j): # i 의 j번 비트가 1인 경우
              subset.append(arr[j])
          if len(subset) == 3:
              print(subset)
  
              
  # 연속된 부분집합
  arr = [3, 6, 7, 1, 5, 4]  # 주어진 리스트
  n = len(arr)  # 리스트의 길이, 즉 원소의 개수
  
  for start in range(n):  # 연속된 부분집합 생성을 위한 루프
      for end in range(start + 1, n + 1):
          subset = arr[start:end]
          print(subset)
              
   # 특정 원소가 들어간 부분집합
  arr = [3, 6, 7, 1, 5, 4]  # 주어진 리스트
  n = len(arr)  # 리스트의 길이, 즉 원소의 개수
  target_element = 5  # 찾고자 하는 특정 원소
  
  # 특정 원소가 들어간 부분집합 생성을 위한 루프
  for i in range(1 << n):  # 부분집합의 개수만큼 반복
      subset = []  # 현재 부분집합을 저장할 리스트
      for j in range(n):  # 원소의 수만큼 비트를 비교함
          if i & (1 << j):  # i의 j번 비트가 1인 경우
              subset.append(arr[j])
      if target_element in subset:
          print(subset)
  
              
              
  # end =", " 
  출력 항목 사이에 콤마와 공백을 추가하여, 한 줄로 나열하면서 줄바꿈을 하지 않도록 설정하는 것.
  ```

  ```python
  # 검색
  
  - 순차 검색
  첫 원소부터 순서대로 검색 대상과 키 값이 같은 원소가 있는지 비교하며 찾는다.
  시간 복잡도 : O(n)
  
  
  # 이진 검색
  자료의 가운데에 있는 항목의 키 값과 비교하여 다음 검색의 위치를 결정하고 검색을 계속 진행하는 방법
  목적 키를 찾을 때까지 이진 검색을 순환적으로 반복 수행.
  # 정렬된 상태여야 한다.
  검색 범위의 시작점과 종료점을 이요하여 검색을 반복 수행한다.
  자료에 삽입이나 삭제가 발생하면 배열의 상태를 항상 정렬상태로 유지하는 추가작업이 필요.
  
  ```

  ```python
  인덱스라는 용어는 Database에서 유래했으며, 테이블에 대한 동작 속도를 높여주는 자료 구조를 말한다.
  Look up table등의 용어를 사용하기도 한다.
  ```

  ```python
  #선택 정렬
  주어진 자료들 중 가장 작은 값의 원소부터 차례대로 선택하여 위치를 교환하는 방식
  최소값을 찾아서 리스트 맨 앞의 위치한 값과 교환, 맨 처음 위치를 제외한 나머지 리스트를 대상으로 위의 과정을 반복한다.
  def selectionsort(a[], n):
      for i from 0 to n-2:
          min(arr) = a[k]
          a[i], a[k] = a[k], a[i]
  
          
  def selection(a, N):
      for i in range(N-1):
          minIdx = i
          for j in range(i+1, N):
              if a[minIdx] > i[j]:
                  minIdx = j
          a[i], a[minIdx] = a[minIdx], a[i]
                 
              
  # 셀렉션 알고리즘
  저장되어 있는 자료로부터 k번째로 큰 혹은 작은 원소를 찾는 방법.
  정렬을 하고, 원하는 순서에 있는 원소 가져오기
  # k번째로 작은 원소
  def select(arr, k):
      for i in range(0, k):
          minIndex = i
          for j in range(i+1, len(arr)):
              if arr[minIndex] > arr[j]:
                  minIndex = j
          arr[i], arr[minIndex] = arr[minIndex], arr[i]
      return arr[k-1]
  ```

  

- 2진 탐색 문제

  ```python
  """
  짝을 이룬 A, B 두 사람에게 교과서에서 각자 찾을 쪽 번호를 알려주면, 이진 탐색만으로 지정된 페이지를 먼저 펼치는 사람이 이기는 게임이다.
  
  예를 들어 책이 총 400쪽이면, 검색 구간의 왼쪽 l=1, 오른쪽 r=400이 되고, 중간 페이지 c= int((l+r)/2)로 계산한다.
  
  찾는 쪽 번호가 c와 같아지면 탐색을 끝낸다.
  """
  T = int(input())
  
  for tc in range(1, T+1):
      P, Pa, Pb = map(int, input().split())
  
      l = 1
      r = P
      now_a = 0
      count_a = 0
      while l <= r:
          now_a = int((l+r)/2)
          count_a += 1
          if now_a < Pa:
              l = now_a
          elif now_a > Pa:
              r = now_a
          else:
              break
  
      l = 1
      r = P
      now_b = 0
      count_b = 0
      while l <= r:
          now_b = int((l+r)/2)
          count_b += 1
          if now_b < Pb:
              l = now_b
          elif now_b > Pb:
              r = now_b
          else:
              break
  
      if count_a == count_b:
          result = 0
      elif count_a < count_b:
          result = 'A'
      else:
          result = 'B'
  
      print(f'#{tc} {result}')
  ```

  



- 결과 출력 시 괄호 빼는 법

  ```python
  print(f'#{tc}', *result)
  ```



- 배열 출력

  ```python
  for i in arr:
      print(*i)
  ```

  

- 델타를 이용한 알고리즘

  ```python
  # 주변 델타 값 정의 (상, 하, 좌, 우)
  dx = [-1, 1, 0, 0]
  dy = [0, 0, -1, 1]
  
  # 2차원 격자(행렬) 예시
  arr = [
      [1, 2, 3],
      [4, 5, 6],
      [7, 8, 9]
  ]
  
  i = len(arr)
  j = len(arr[0])
  
  for i in range(N):
      for j in range(M):
          for d in range(4):
              ni = i + dx[d]
              nj = j + dy[d]
              
              if 0 <= newRow < rows and 0 <= newCol < cols:
                  # 주변 요소에 대한 작업 수행
                  print("Current Cell:", grid[row][col])
                  print("Neighbor Cell:", grid[newRow][newCol])
  
  ```

  

- 달팽이

  ```python
  T = int(input())
  
  for tc in range(1, T+1):
      N = int(input())
  
  # 우 하 좌 상 (달팽이 방향)
      di = [0, 1, 0, -1]
      dj = [1, 0, -1, 0]
  
  # N*N을 0으로 채운 배열 생성
      arr = [[0]*N for _ in range(N)]
  
  # 시작점
      i, j = 0, 0
  
  # 시작 방향(오른쪽)
      d = 0
  
  # 1부터 N*N까지의 n을 배열에 넣기
      for n in range(1, N*N +1):
          arr[i][j] = n
  
  # ni, nj = next i,j / 다음 위치
          ni = i + di[d]
          nj = j + dj[d]
  
  # 범위를 벗어나거나 위치에 0이 아닐 경우 방향 바꾸기
          if ni < 0 or nj < 0 or ni >= N or nj >= N or arr[ni][nj] != 0:
  # d 가 범위를 벗어나거나 그 자리에 0이 아닐 때마다 d의 방향 변경 
              d = (d + 1) % 4
  # ni, nj 위치 재 변경
              ni = i + di[d]
              nj = j + dj[d]
  # arr[i][j], 현재 위치 재설정
          i = ni
          j = nj
  
      print(f'#{tc}')
  # 배열 출력
      for i in arr:
          print(*i)
  ```

  - 회전

  ```python
  T = int(input())
  
  for tc in range(1, T+1):
      N = int(input())  # N*N배열
      arr = [list(map(int, input().split())) for i in range(N)]  # 배열 입력
  
      # 새로운 2차원 리스트 생성
      new_lst = [[0 for _ in range(N)] for _ in range(N)]
      for i in range(N):
          for j in range(N):
              new_lst[j][N-1-i] = arr[i][j]
  
      new_lst2 = [[0 for _ in range(N)] for _ in range(N)]
      for i in range(N):
          for j in range(N):
              new_lst2[j][N - 1 - i] = new_lst[i][j]
  
      new_lst3 = [[0 for _ in range(N)] for _ in range(N)]
      for i in range(N):
          for j in range(N):
              new_lst3[j][N - 1 - i] = new_lst2[i][j]
  
      print(f'#{tc}')
      for i in range(N):
          for a in range(N):
              print(new_lst[i][a], end='')
          print(end=' ')
          for b in range(N):
              print(new_lst2[i][b], end='')
          print(end=' ')
          for c in range(N):
              print(new_lst3[i][c], end='')
          print()
  ```

  