## 8.29 논리

- 명제

  참이나 거짓을 알 수 있는 식이나 문장

- 진리값

  참이나 거짓을 표현 (T/F, 1/0)



- 부정 NOT

  ~p 또는 ┓p로 표기 (not p 또는 p의 부정으로 읽음)

- 논리 곱 AND
  - p, q가 명제일 때, p, q 모두 참일 때만 참이 되는 명제 (둘 다 F일 때도 F)
  - p^q (p and q, p 그리고 q)

- 논리 합 OR
  - p, q가 명제일 때, p, q 모두 거짓일 때만 거짓이 되는 명제
  - p V q (p or q, p 또는 q)

- 배타적 논리합 XOR

  - p, q가 명제일 때, p, q 중 '하나만 참일 때' 참이 되는 명제

  - p ⊕ q (p xor q)

    

- 연산자 우선순위

  - not(~), and / or, 방향 

  

- 명제 종류
  - 항진 명제 : 진릿값이 항상 참
  - 모순 명제 : 진릿값이 항상 거짓
  - 사건 명제 : 항진명제, 모순명제가 아닌 명제



- 조건 명제
  - p, q가 명제일 때, 명제 p가 조건(또는 원인), q가 결론(또는 결과)로 제시되는 명제
  - p -> q (p이면 q이다.)

- 쌍방 조건 명제
  - p, q가 명제일 때, 명제 p와 q가 모두 조건이면서 결론인 명제
  - p  ⑫ q (p명 q이고, q면 p이다.)



- 조건 명제의 역, 이, 대우

  - 역 : q이면 p이다.
  - 이 : not p이면 not q 이다.
  - 대우 : not q 이면 not p이다.

  

- p->q 를 p <->q 와 혼동하지 말 것.



- 재귀

  자기 자신을 호출하는 함수. 그럼 끝날 수가 있는가?

  자기 자신의 입력과 동일한 입력으로 자기 자신을 호출하면 끝나지 않음

  다른 입력으로 호출해야 끝날 수 있다.



- 함수

  함수란 어떤 문제를 해결하는 방법을 코딩한 것.

  함수가 어떤 문제의 단 한 케이스만을 해결하는 것이 아님

  제대로 코딩 된 것이라면 해결하는 문제의 모든 케이스들을 해결해야 함.

  

- 수학적 귀납법 증명 사용 가능
  - n이 0일 때 문제 풀 수 있음
  - n-1에서 문제를 풀 수 있으면 n에서도 문제를 풀 수 있다.
  - 위 두 가지가 사실이면 모든 가능한 n에 대해 문제를 풀 수 있다.



- 다르게 생각하기!

  - 어떤 문제를 해결하려다 부분 문제를 만났는데, 원래 해결하려던 입력 케이스와 동일한 문제에 속하지만

    "크기가 더 작은" 입력 케이스를 해결하는 것이 그 부분 문제였다.

    즉, 부분 문제가 동일한 문제인 경우

    

- 동적 프로그래밍

  - 재귀 함수에서 동일한 입력의 함수 호출이 반복적으로 일어날 때 그 결과 값을 저장해 두고 불러 쓰는 것.(Memoization)

  - 최초 입력에서 파생되는 모든 가능한 입력에 대한 답을 모두 저장할 수 있는 메모리가 있어야 한다.

  - 단순히 재귀에서 저장된 값을 찾아보는 것으로도 가능하지만, 결과 값을 순서를 정해서 계산할 수도 있다.

    (DP)